大前提();
指示書();



大前提()
{
    回答は高校生が読んでも分かるように、程可読性に配慮したカジュアルな表記をせよ。
}



指示書()
{
    下記の要件で開発を進める。
    開発は順を追って進めるため、セグメントごとにチャットを分ける。あなたは、こちらが一言目に要求したセグメントの開発を手伝ってください。



    【要件】
    ---

    # アバター服フィット & 肌貫通除去システム 構想メモ（引き継ぎ用）

    ## 0. 前提とゴール

    ### 開発環境    
    Unity6.2 の URP

    ### ゴール

    * **任意アバター × 任意の服**を、ある程度汎用的にフィットさせたい。
    * 物理シミュレーション（クロス/剛体）は使わずに、

      * マーカー＋Wrap Mesh で「大まかなフィット」
      * Ray＋マスク焼きで「服からはみ出した肌だけを自動で不可視化」
        を実現する。
    * 一度マスクを計算したらキャッシュし、**同じアバター×服の組み合わせでは再利用**して、着替えを高速に行う。

    ### 非ゴール / しないこと

    * 完全自動で、どんなアバター＆どんな服でも**完璧に**フィットさせること。
    * 常時リアルタイムで再計算するような**重い物理シミュレーション**。
    * 「服に隠れているボディ全部を消す」方式（今回は **貫通部分だけ** を消したい）。

    ---

    ## 1. 全体アーキテクチャ

    構成はざっくり 3 レイヤー：

    1. **マーカーによる大まかな位置合わせ**

      * アバターと服の両方に、共通プロトコルの「マーカー（アンカー）」Transformを持たせる。
      * 着せるときに、対応マーカー同士を使って服の位置/回転/スケールを調整する。

    2. **Wrap Mesh（MegaFiers 2）の追従レイヤ**

      * Wrap Mesh（MegaFiers 2）を使い、服メッシュをアバターのボディメッシュに「Wrapバインド」する。
      * その後のボーンアニメ、体型モーフ、MegaFiers変形などを服側にもコピーさせる。
      * Wrap は「変形コピー役」であり、「サイズ合わせ」は別レイヤ（マーカーやFFD）で行う。

    3. **Ray＋マスク焼きによる肌貫通除去レイヤ**

      * アバターのボディ頂点から Ray を撃ち、
      * 「外側に肌、そのすぐ後ろに服」がある頂点を「貫通している肌」と判定。
      * その頂点だけを不可視にするための **マスクを頂点カラーに焼く**。
      * 一度焼いたら **(AvatarID, ClothID)** 単位でキャッシュし、以降は読み込みだけで使う。

    このメモを見たLLMには、**まずはレイヤ3（Ray＋マスク焼き）の最小実装**設計・相談から頼みたい。

    ---

    ## 2. キャッシュ単位（重要ポイント修正）

    * マスクは **「アバター × 服」の組み合わせごと** に 1 回だけ焼けば良い前提。
    * 同じアバターは体型が変化しない想定なので、キャッシュのキーは：

    > **Key = (AvatarID, ClothID)**

    * AvatarID は「そのアバターPrefab / メッシュバリアントを一意に表すID」（パスでもGUIDでも可）。
    * ClothID も同様に「その服メッシュ / Prefab を一意に表すID」。
    * 将来、**同アバターで複数体型（スライダーなど）**を導入するなら、そのときに「体型バージョン」などをキーに追加する余地がある、という程度のイシューとして保留。

    ---

    ## 3. マーカー ＋ Wrap Mesh（今は概要だけ）

    ### 3-1. マーカー

    * アバター側：

      * 例：`Chest`, `Spine`, `Waist`, `Hip`, `Thigh_L`, `Thigh_R` …など。
      * 「どのマーカーが体のどの位置を意味するか」はプロトコルとして固定する。

    * 服側：

      * 同名のマーカーを仕込む（手作業 or 半自動ツール）。

    * 着せるとき：

      * 対応するマーカー同士（アバターのChestと服のChestなど）が揃うように、

        * 服の位置・回転・スケールを調整して「大まかに合う」ところまで持っていく。

    ※ マーカーの詳細な種類一覧やプロトコルは、**別イシュー**として詰める。

    ### 3-2. Wrap Mesh（MegaFiers 2）の役割

    * Wrap Mesh は、

      * 「最初からそのボディにフィットしている服」をターゲットボディにバインドし、
      * その後のアニメ／変形を服側にもコピーする仕組み。
    * 本構想では、

      * マーカー等でざっくりフィットさせた服に Wrap をかけ、
      * 以降のボーンアニメ・体型モーフ・MegaFiers変形を服にも追従させる。
    * 重要な点：

      * Wrap Mesh 自体は「サイズフィッティング」ではなく「変形のコピー」。
      * サイズ差の吸収は、マーカー＋MegaFiersのFFD/Bendなどのレイヤで行う。

    ---

    ## 4. Ray＋マスク焼きによる「服からはみ出した肌だけ」不可視化

    ここがこのメモの**一番重要な部分**。

    ### 4-1. コンセプト

    * やりたいのは：

      * **「服からはみ出して見えてしまっている肌」だけをピンポイントで不可視化**すること。
    * やりたくないのは：

      * 「服の下のボディ全部を削る」＝普通の絵作りでよくある方式。
      * 穴の空いた服（Vネック、スリットなど）で肌が見えなくなるのはNG。

    → そのため、
    **「外から見たときに、肌が服より外側にいる部分」だけを特定して消す** というロジックを採用する。

    ---

    ### 4-2. なぜカメラ方向RayはNGか

    * カメラ位置から画面各ピクセル方向へRayを撃って判定する方式は、

      * 「そのカメラ視点では」貫通を判定できる。
      * しかし、カメラを動かすとまた別の貫通が現れる。
      * 毎フレーム or カメラ移動ごとに再計算が必要になる。

    * 今回の方針は：

      * **「一度だけ計算してマスクを焼き、以降はキャッシュを使う」**
      * かつ **視点非依存**の形状ベース判定。

    → よって、**カメラ方向ではなく、各ボディ頂点の「外向き法線方向」を基準にした Ray** を使う。

    ---

    ### 4-3. Ray の撃ち方（確定案）

    #### 対象頂点

    * 本来は「服の影響範囲内の頂点だけ」を対象にした方が効率的だが、

      * 初期実装ではシンプルに「ボディメッシュ全頂点」を対象にしてよい。
      * 高速化のためのバウンディングボックス絞り込みは**後のイシュー**。

    #### 座標とタイミング

    * ボディは SkinnedMesh（ウェイト＋ボーン）を前提とする。
    * マスク焼きは「ある1ポーズ」（Tポーズ or 基本ポーズ）で行う想定。
    * 頂点位置 `v` と法線 `n` は、**スキニング後のワールド座標系**で取得する必要がある（ボーン変形を反映済み）。

    #### 手順

    各ボディ頂点 `v`（外向き法線 `n`）に対して：

    1. 外側のスタート点 `p` を決める：

      * `p = v + n * D`
      * `D` は、アバターのスケールにもよるが「ボディ＋服＋余裕」をカバーできる十分大きな値（例：メートル系なら 0.2〜0.5 など）。
      * `p` は「ボディと服をすべて包む球の外側」にいるイメージ。

    2. 方向ベクトルは **逆法線 `-n`**（外→内）。

    3. `p` から `-n` に向けて **RaycastAll** を行う。

      * レイヤーマスクを使い、「ボディコライダ」と「服コライダ」以外は無視する（環境オブジェクトなど不要）。

    4. RaycastAll の結果を **ヒット距離の昇順にソート**し、

      * その中で「ボディと服がどの順序で出てくるか」を見る。

    ※ 実装は Unity の `RaycastCommand` を使って Burst/Jobs で並列処理するのが望ましい。
    　参考：`Hines94/CharacterClippingProtector`（後述）。

    ---

    ### 4-4. 貫通判定ロジック（順序判定）

    `p` から `-n` 方向に見たときの「外側→内側」のヒット順を以下のように解釈する：

    #### パターンA：最初に服、その後にボディ

    * ヒット順：**服 → ボディ**
    * 外側には服、その内側にボディがある。
    * これは「服の中に肌が収まっている」正常な状態。
    * → この頂点は **貫通していない** と判定（マスクしない）。

    #### パターンB：最初にボディ、その後に服

    * ヒット順：**ボディ → 服**
    * 外側に肌、そのすぐ後ろに服がある。
    * これは「肌が服の外側に飛び出している」状態。
    * → この頂点を **貫通している肌**と判定し、マスク対象にする。

    #### パターンC：ボディのみヒット（服ヒット無し）

    * ヒット順：**ボディのみ**
    * その方向には服が存在しない → 袖なし・短パン・穴から見える肌など。
    * → 普通の露出肌。**マスクしない**。

    #### パターンD：その他（何も当たらない／特殊な組み合わせ）

    * 例：

      * Ray がボディにも服にも当たらない（データ外、極端な凹みなど）。
      * ボディ→ボディ→服 のような複雑な順序。
    * 現段階の初期実装では、

      * 安全側として **マスクしない** と扱う（貫通検出の漏れがあっても、肌が見えるだけで致命傷ではない）。
    * 脇の下・股の内側のような「複雑な凹み」は、このカテゴリに入りやすいので、
      後の改善イシュー（複数方向Rayなど）として扱う。

    #### 穴あきの服について

    * 服に穴がある方向では、Ray は「ボディには当たるが、服には当たらない」＝パターンCになる。
    * よって、穴越しに見える肌は **マスクされず残る**。
    * 「穴部分の肌が誤って消える」問題は起こりにくい。

    ---

    ### 4-5. マスクの表現方法（頂点カラー）

    今回の初期実装では、マスク値は **メッシュの頂点カラー** に保存する。

    #### マスク値の定義

    * Ray 判定の結果：

      * 貫通している頂点 → `mask = 1.0`
      * その他の頂点 → `mask = 0.0`

    * これをメッシュの `colors`（頂点カラー）の R チャンネルに書く：

      * 例：`color.r = mask`, G/B/A は 0 or 1 など適当（用途があれば別途）。

    #### シェーダ側での利用イメージ

    * ボディ用シェーダーで、頂点カラーを受け取る。

    * フラグメントシェーダ（ピクセルシェーダ）では、補間された `mask` が渡ってくる。

    * 処理イメージ（HLSL 擬似）：

      ```hlsl
      float mask = input.color.r; // 頂点カラーRチャンネル

      if (mask > 0.5)
      {
          clip(-1); // or discard; → このピクセルを描画しない
      }

      // 通常のアルベド計算などをここで実施
      ```

    * これにより、

      * 「服より外に出てしまった肌の部分だけ」をピンポイントに不可視化できる。
      * その部分は服で覆われている前提なので、カメラを回しても「肌の切れ目」が見えにくい。

    #### 解像度について

    * マスク解像度はメッシュの頂点密度に依存。
    * ローポリだと、マスク境界がやや粗くなる可能性はあるが、

      * 初期実装としては許容。
      * 高精度が必要なら、将来的に「マスクテクスチャ（UV1＋白黒マップ）」方式へ発展可能。

    ---

    ### 4-6. 実行タイミングとキャッシュ

    #### 実行タイミング

    * 重い処理であることは許容するが、**一度だけ実行して結果を保存**する前提。

    * 想定フロー：

      1. 初めての組み合わせ `(AvatarID, ClothID)` で服を着せる（マーカー＋Wrapである程度フィット）。
      2. この状態で、ボディメッシュに対して Ray＋マスク焼き処理を実行。
      3. マスク付きメッシュ（あるいは頂点カラー配列）を、
        `(AvatarID, ClothID)` の組み合わせ用に保存（ファイル or ScriptableObjectなど）。
      4. 以降、同じ `(AvatarID, ClothID)` の着替えでは、保存済みマスクを読み込むだけでOK。

    * ボディメッシュの形状が大きく変わる（別アバターに替えるなど）場合は、

      * AvatarID 自体が変わる前提なので、**別キャッシュとして扱う**。

    #### 将来の拡張余地（体型変化）

    * 将来、

      * 同じアバターでスライダー体型変更などを導入したい場合、
      * 体型毎にマスク焼きが必要になるため、
      * `(AvatarID, BodyShapeVariantID, ClothID)` のようなキーに拡張する余地はある。
    * 現時点では **体型固定前提**で進める。

    ---

    ## 5. 既知のイシュー / 今後の課題

    ここから先は「今はやらないけど、議論済みで気になっているポイント」。

    ### Issue 1: マーカーと服デフォーム（MegaFiers）の詳細設計

    * どのマーカーをどのボーン／体表位置に置くか。
    * 着せる前後に MegaFiers の FFD/Bend 等をどう当てて、

      * 服を体型にフィットさせるか。
    * 「削ったボディ境界を、服の裏面に縫い付けるような変形」を追加するかどうか。

      * 例：はみ出し部分付近で服の裏面を少しふくらませる等。
    * これらは **イシューとして残すだけで、今は手を付けない**。

    ### Issue 2: 高速化（バウンディングボックスで頂点絞り込み）

    * 初期実装では「ボディ全頂点」を対象にRay判定。
    * 将来的には、

      * 服メッシュのバウンディングボックスを少し膨らませた領域に入っている頂点だけを対象にすることで、
      * Ray本数を削減して高速化したい。
    * これは最適化イシュー。

    ### Issue 3: 法線が直感と違う方向を向いている頂点

    * 脇の下・股の内側など、複雑な凹み部分では

      * 法線が「期待する外側方向」とズレることがある。
    * そういった場所では、

      * 法線1本だけのRayだと貫通検出に漏れが出る可能性がある。
    * 将来的な改善案：

      * 問題の出やすい部位だけ、Ray方向を複数本（法線＋少し回転させた方向）撃ってみる。
      * 部位ごとに処理を変える など。

    ### Issue 4: 横方向にだけ飛び出している貫通

    * 例：

      * 肩の横から肌が飛び出しているが、その頂点の法線はほぼ上向き。
    * この場合：

      * 上↔下方向から見ると服の中に収まっている（パターンA判定）。
      * しかし真横から見ると貫通しているように見える。
    * 法線1方向だと、この種の貫通を見逃すことがある。
    * 将来的には：

      * 必要に応じて「法線以外の方向にもRayを撃つ」などで対応検討。

    ---

    ## 6. 参考プロジェクト（実装のたたき台）

    * **CharacterClippingProtector**（作者: Hines94）

      * GitHub リポジトリ（コード本体）：

        * `Hines94/CharacterClippingProtector`
      * スクリーンショット：

        * `Hines94/ImagesForRepos/blob/master/ClipperRunning.png` など。
      * コンセプト：

        * 各頂点から「外から内へ」Rayを撃って、服に隠れるボディを検出し、
          新しいメッシュを生成して隠すツール。
        * Unity の `RaycastCommand` を使って大量RayをBurst/Jobsで並列処理している。
      * 本プロジェクトでは：

        * **大量Rayを撃つ技術的部分**はここを参考にする。
        * 判定ロジックは「服の下のボディ全部」ではなく、
          **「ボディ→服の順でヒットした頂点だけ」を削る**ように変更する。

    ---

    ## 7. このメモを読んだLLMへの依頼（引き継ぎ内容）

    このメモを引き継いだLLMには、まず以下をお願いしたい：

    1. 上記方針に沿って、
      **頂点カラーを使った「貫通マスク焼き」の最小実装**を一緒に設計してほしい。

      * Unity C#側の処理フロー（疑似コードレベルでOK）：

        * ボディSkinnedMeshの頂点と法線（ワールド座標）取得
        * 各頂点に対し `p = v + n * D` → `-n` 方向へ RaycastAll
        * ヒット結果から「ボディ→服順ヒット」を検出し、頂点カラーRに `1.0` をセット
        * その他は `0.0` にセット
      * メッシュ（or複製メッシュ）に頂点カラーを焼き込む処理
      * `(AvatarID, ClothID)` ごとのキャッシュ戦略

    2. ボディ用シェーダー側の設計：

      * 頂点カラーRをマスク値として受け取り、
      * `mask > 0.5` のとき `clip(-1)` する処理を含めたHLSL構成（擬似コードでもOK）。

    3. 余裕があれば：

      * マーカーのプロトコル設計（どのマーカーを使うかの案だし）。
      * Wrap Mesh（MegaFiers 2）との連携フローの素案。
      * 上記イシュー（高速化、複数方向Ray、横方向貫通など）の改善案もアイデアレベルで検討。

    ---
}
